replicaCount: 2

image:
  repository: quay.io/mittwald/kube-httpcache
  pullPolicy: IfNotPresent
  tag: "stable"


nameOverride: "skind-cache"
fullnameOverride: "skind-varnish-httpcache"

# Enable StatefulSet (Deployment is default)
useStatefulset:
  enabled: true

# Enable configMap for Varnish Template File (see below vclTemplate)
# OR use extravolume with name "template" if the file is too big
configmap:
  enabled: true

# kube-httpcache specific configuration
cache:
  # name of frontend service
  # frontendService: kube-httpcache-headless
  # name of backend service
  backendService: skind-minotar-skind
  # name of backend service namespace
  # backendServiceNamespace: backend-service-namespace
  # watching for frontend changes is true by default
  frontendWatch: true
  # watching for backend changes is true by default
  backendWatch: true
  # Varnish storage backend type (https://varnish-cache.org/docs/trunk/users-guide/storage-backends.html)
  varnishStorage: malloc # default,malloc,umem,file...
  # Varnish storage backend size
  storageSize: 64M # K(ibibytes), M(ebibytes), G(ibibytes), T(ebibytes) ... unlimited
  # Varnish transient storage backend type (https://varnish-cache.org/docs/trunk/users-guide/storage-backends.html)
  varnishTransientStorage: malloc
  # Varnish transient storage backend size
  transientStorageSize: 32M # K(ibibytes), M(ebibytes), G(ibibytes), T(ebibytes) ... unlimited
  # Secret for Varnish admin credentials
  secret: "this_is_not_publicly_accessible"
  # Read admin credentials from user provided secret
  #existingSecret: kubecache-secret

cacheExtraArgs: {}
# cacheExtraArgs: |
  # - -v=8
  # - -varnish-additional-parameters=vcc_allow_inline_c=on

service:
  type: ClusterIP
  port: 80
  target: 80

resources:
  limits:
    memory: 500Mi
  requests:
    cpu: 100m
    memory: 128Mi


affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        topologyKey: "kubernetes.io/hostname"
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - skind-cache
          - key: app.kubernetes.io/instance
            operator: In
            values:
            - skind-varnish

livenessProbe: {}
# livenessProbe:
#   httpGet:
#    path: /
#    port: 6083
readinessProbe: {}

vclTemplate: |
  vcl 4.0;

  import std;
  import directors;

  // ".Frontends" is a slice that contains all known Varnish instances
  // (as selected by the service specified by -frontend-service).
  // The backend name needs to be the Pod name, since this value is compared
  // to the server identity ("server.identity" [1]) later.
  //
  //   [1]: https://varnish-cache.org/docs/6.4/reference/vcl.html#local-server-remote-and-client
  {{ range .Frontends }}
  backend {{ .Name }} {
      .host = "{{ .Host }}";
      .port = "{{ .Port }}";
  }
  {{- end }}

  {{ range .Backends }}
  backend be-{{ .Name }} {
      .host = "{{ .Host }}";
      .port = "{{ .Port }}";
  }
  {{- end }}

  sub vcl_init {
      new cluster = directors.hash();

      {{ range .Frontends -}}
      cluster.add_backend({{ .Name }}, 1);
      {{ end }}

      new lb = directors.hash();

      {{ range .Backends -}}
      lb.add_backend(be-{{ .Name }}, 1);
      {{ end }}

  }

  sub sanitize_incoming
  {
      # Non-skind paths are dropped
      if (req.url !~ "^/skin/" && req.url !~ "^/download/") {
        return(synth(403));
      }

      # Let's remove all query strings, ampersands and hashes
      # These should not appear in any requests and are unrequired.
      if (req.url ~ "\?|&|#") {
        set req.url = regsub(req.url, "(\?|&|\#).*$", "");
      }

      # Remove all cookies
      unset req.http.cookie;
  }

  sub vcl_recv
  {
      # Set backend hint for non cachable objects.
      set req.backend_hint = lb.backend(req.url);

      call sanitize_incoming;

      # Remove the resource type from the URL for calculating the hash
      # (eg. so hash is only from Username/UUID so we always query same skind)
      set req.http.X-Req-Hash = regsub(req.url, "/(skin|download)", "");

      # Routing logic. Pass a request to an appropriate Varnish node.
      # See https://info.varnish-software.com/blog/creating-self-routing-varnish-cluster for more info.
      unset req.http.x-cache;
      set req.backend_hint = cluster.backend(req.http.X-Req-Hash);
      set req.http.x-shard = req.backend_hint;
      if (req.http.x-shard != server.identity) {
          return(pass);
      }

      ## Request was meant for this Varnish shard
      set req.backend_hint = lb.backend(req.http.X-Req-Hash);

      return(hash);
  }

  # Handle the HTTP request coming from our backend
  sub vcl_backend_response
  {
      # Called after the response headers has been successfully retrieved from the backend.

      # Remove all cookies, cache everything
      unset beresp.http.Set-Cookie;

      # Return backend name with each request
      if (beresp.http.X-Backend) {
        set beresp.http.X-Backend = beresp.http.X-Backend + ", " + beresp.backend.name;
      } else {
        set beresp.http.X-Backend = beresp.backend.name;
      }

      # Allow stale content, in case the backend goes down.
      # make Varnish keep all objects for 1.5 hours beyond their TTL
      set beresp.grace = 30m;
      # Keep optimizes If-None-Match
      set beresp.keep = 1h;

      return (deliver);
  }

  sub vcl_deliver
  {
      # Called before a cached object is delivered to the client.

      # Set debug info headers
      set resp.http.X-Req-Hash = req.http.X-Req-Hash;

      set resp.http.X-Varnish-Server = server.identity;

      # Only add the object headers when it was served by this shard
      if (req.http.x-shard == server.identity) {
        if (obj.hits > 0) { # Add debug header to see if it's a HIT/MISS and the number of hits, disable when not needed
          set resp.http.X-Cache = "HIT";
        } else {
          set resp.http.X-Cache = "MISS";
        }

        if (req.http.grace) {
          set resp.http.X-Grace = req.http.grace;
        }

        # Please note that obj.hits behaviour changed in 4.0, now it counts per objecthead, not per object
        # and obj.hits may not be reset in some cases where bans are in use. See bug 1492 for details.
        # So take hits with a grain of salt
        set resp.http.X-Cache-Hits = obj.hits;
      }

      call header_cleanup;
  }

  # Header cleanup and removal for headers which we don't want making it to the clients.
  sub header_cleanup
  {
      unset resp.http.X-Powered-By;
      unset resp.http.Server;
      unset resp.http.X-Drupal-Cache;
      unset resp.http.X-Varnish;
      unset resp.http.Via;
      unset resp.http.Link;
      unset resp.http.X-Generator;

      return (deliver);
  }
