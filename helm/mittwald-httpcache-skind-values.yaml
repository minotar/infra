replicaCount: 2

image:
  repository: quay.io/mittwald/kube-httpcache
  pullPolicy: IfNotPresent
  tag: "stable"


nameOverride: "skind-cache"
fullnameOverride: "skind-varnish-httpcache"

# Enable StatefulSet (Deployment is default)
useStatefulset:
  enabled: true

# Enable configMap for Varnish Template File (see below vclTemplate)
# OR use extravolume with name "template" if the file is too big
configmap:
  enabled: true

# kube-httpcache specific configuration
cache:
  # name of frontend service
  # frontendService: kube-httpcache-headless
  # name of backend service
  backendService: skind-minotar-skind
  # name of backend service namespace
  # backendServiceNamespace: backend-service-namespace
  # watching for frontend changes is true by default
  frontendWatch: true
  # watching for backend changes is true by default
  backendWatch: true
  # Varnish storage backend type (https://varnish-cache.org/docs/trunk/users-guide/storage-backends.html)
  varnishStorage: malloc # default,malloc,umem,file...
  # Varnish storage backend size
  storageSize: 64M # K(ibibytes), M(ebibytes), G(ibibytes), T(ebibytes) ... unlimited
  # Varnish transient storage backend type (https://varnish-cache.org/docs/trunk/users-guide/storage-backends.html)
  varnishTransientStorage: malloc
  # Varnish transient storage backend size
  transientStorageSize: 32M # K(ibibytes), M(ebibytes), G(ibibytes), T(ebibytes) ... unlimited
  # Secret for Varnish admin credentials
  secret: "this_is_not_publicly_accessible"
  # Read admin credentials from user provided secret
  #existingSecret: kubecache-secret

cacheExtraArgs: {}
# cacheExtraArgs: |
  # - -v=8
  # - -varnish-additional-parameters=vcc_allow_inline_c=on

service:
  type: ClusterIP
  port: 80
  target: 80

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi


affinity: {}

livenessProbe: {}
# livenessProbe:
#   httpGet:
#    path: /
#    port: 6083
readinessProbe: {}

vclTemplate: |
  vcl 4.0;

  import std;
  import directors;

  // ".Frontends" is a slice that contains all known Varnish instances
  // (as selected by the service specified by -frontend-service).
  // The backend name needs to be the Pod name, since this value is compared
  // to the server identity ("server.identity" [1]) later.
  //
  //   [1]: https://varnish-cache.org/docs/6.4/reference/vcl.html#local-server-remote-and-client
  {{ range .Frontends }}
  backend {{ .Name }} {
      .host = "{{ .Host }}";
      .port = "{{ .Port }}";
  }
  {{- end }}

  {{ range .Backends }}
  backend be-{{ .Name }} {
      .host = "{{ .Host }}";
      .port = "{{ .Port }}";
  }
  {{- end }}

  sub vcl_init {
      new cluster = directors.hash();

      {{ range .Frontends -}}
      cluster.add_backend({{ .Name }}, 1);
      {{ end }}

      new lb = directors.hash();

      {{ range .Backends -}}
      lb.add_backend(be-{{ .Name }}, 1);
      {{ end }}

  }

  sub sanitize_incoming
  {
      # Non-skind paths are dropped
      if (req.url !~ "^/skin/" && req.url !~ "^/download/") {
        return(synth(403));
      }

      # Let's remove all query strings, ampersands and hashes
      # These should not appear in any requests and are unrequired.
      if (req.url ~ "\?|&|#") {
        set req.url = regsub(req.url, "(\?|&|\#).*$", "");
      }

      # Remove all cookies
      unset req.http.cookie;
  }

  sub vcl_recv
  {
      # Set backend hint for non cachable objects.
      set req.backend_hint = lb.backend(req.url);

      call sanitize_incoming;

      # Routing logic. Pass a request to an appropriate Varnish node.
      # See https://info.varnish-software.com/blog/creating-self-routing-varnish-cluster for more info.
      unset req.http.x-cache;
      set req.http.x-req-hash = regsub(req.url, "/(skin|download)", "");
      set req.backend_hint = cluster.backend(req.http.x-req-hash);
      set req.http.x-shard = req.backend_hint;
      if (req.http.x-shard != server.identity) {
          return(pass);
      }
      set req.backend_hint = lb.backend(req.http.x-req-hash);

      # ...

      return(hash);
  }

  sub vcl_deliver
  {
      # Set debug info headers
      set resp.http.x-shard = req.backend_hint;
      set resp.http.x-varnish-server = server.identity;
      set resp.http.x-req-hash = req.http.x-req-hash;
  }
